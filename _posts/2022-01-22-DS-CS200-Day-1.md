# DS Day 1

Version control systems in general. Today, the GIT Object Model
A rudimentary VCS can be a version database on a local computer. At the checkout, there exists a pointer to the latest version.

Another approach was having a centralised VCS server. The issue : can’t work offline, single point of failure, availability.
Examples : CVS, subversion,

Solution to this is switch from centralised to distributed. Eg:  Git, Mercurial, Bazaar, Darcs

Bitkeeper controversy lies at the origin of git (created by Linus Torvalds)
Goals of the new VCS :
* Speed
* Simplicity
* Non linear development
* Completely decentralised, distributed

Traditional Version Control Systems - Delta based VCS :
* In the first version, the files are stored.
* In further versions, differences(deltas) are stored 

In git :
* In the first version, the file’s snapshots are stored.
* For each subsequent version, :
    * In changed files, snapshots of the new(changed) files are stored
    * In unchanged files, only a pointer to its last changed version (of the file, and not the repo) are stored
* Great features :
    * Nearly all operations are local
    * Integrity is maintained:
        * Changes, intentional or otherwise, are maintained
        * Can definitely track changes made by the unwanted third party.
    * Generally adds only data
    * States:
        * Modified
        * Staged
        * Committed

Data Model of Git :
* Commit
* Tree
* Blob


Think about :
* Hash function
* Cryptographic hash function


“Git is fundamentally a content-addressable filesystem with a VCS user interface written on top of it.” 
													   - Pro Git Scott Chacon and Ben Straub

The Data Model, In Detail :
* Blob : Used to store file data… generally a file
* Tree : Basically like a directory that references a bunch of other trees and/or blobs… files and sub-directories
* Commit : Commit can be visualised as a snapshot that points to a single tree, marking it as what the project looks like at a certain point in time. Contains
    * Metadata like timestamp, author etc.

To DO:
* Install GitGraph* 
* Think of a project to work on as a group, contributions of each member is necessary.

